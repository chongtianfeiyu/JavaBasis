配置Bean：
----配置形式：基于XML文件的方式，基于注解的方式
----Bean的配置方式：通过全类名(反射)，通过工厂方法(静态工厂方法&实例工厂方法)，FactoryBean
----IOC容器：BeanFactory&ApplicationContext
----依赖注入的方式：属性注入，构造器注入
----注入属性值细节
----自动装配
----bean之间的关系：继承；依赖
----bean的作用域：singleton；prototype；WEB环境作用域
----SpEl表达式


1).初始化Spring容器
	在Spring IOC容器读取Bean配置，并创建Bean实例之前，必须对容器进行实例化。只有在容器实例化后，才能从IOC容器中获取Bean的实例并使用。
	Spring提供了两种类型的IOC容器实现
	--->1，BeanFactory接口：IOC容器的基本实现。
	--->2，ApplicationContext接口：它是BeanFactory的子接口，提供了更多的高级特性。
	
	*BeanFactory是Spring框架的基础设置，面向Spring本身。
	*【ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都直接使用ApplicaContext而非底层的BeanFactory】。
	*两种容器的配置方式都是一致的。
	
	
	ApplicationContext接口的主要实现类：
	--->1，ClassPathXmlApplicationContext：从classpath类路径下加载配置文件。
	--->2，FileSystemXmlApplicationContext：从文件系统中加载配置文件。
	
	【ConfigurationApplicationContext接口扩展于ApplicationContext接口，它新增了两个主要方法】：
	--->1，refresh()
	--->2，close()
	【这让ApplicationContext具有启动，刷新和关闭上下文的能力】。
	
	【ApplicationContext在初始化时就实例化所有的Bean，默认是单例模式的】。
	
	WebApplicationContext是专门为WEB应用而准备的，它允许从相对于WEB根目录的路径中完成初始化的工作。
	

2).从IOC容器中获取Bean
	容器在初始化时就已经完成了所有Bean的初始化工作，通过调用ApplicationContext接口的getBean()方法(很多重载)，可以获取Bean。
	【getBean()方法是从父接口BeanFactory中继承而来的】。
	

3).依赖注入的方式
	--->属性注入
		属性注入即 通过setter方法注入Bean的属性值或者依赖的对象。
		属性注入使用<property>元素，使用name属性指定Bean的属性名，value属性或者<value>子节点指定属性值。
		【属性注入是实际开发中最常用的注入方式】
	--->构造注入
		构造注入即 通过构造方法注入Bean的属性值或依赖的对象，它保证了Bean实例在实例化后就可以使用。
		构造器注入在<constructor-arg>元素中声明属性。<constructor-arg>中没有name属性。
	--->工厂方法注入(不重要，可以忽略)
	
	注入的一些细节：
	-->字面值：
		可用字符串表示的值，可以通过<value>元素标签或者value属性进行植入;
		基本数据类型及其包装类，String等类型都可以采用字面值注入的方式;
		若字面值中包含特殊字符，可以使用<![CADAT[]]>把字面值包裹起来;


4).引用其他的Bean
	--->组成应用程序的Bean经常需要相互协作以完成应用程序的复杂功能，要使Bean之间能够相互访问，就必须在Bean配置文件中指定对Bean的引用；
	--->在Bean的配置文件中，可以通过<property>元素的 ref 属性或者 <ref>元素为Bean的属性或构造器参数指定对Bean的引用；
	--->【也可以在属性或构造器里面包含Bean的声明】，这样的Bean成为内部Bean，不能被外部使用。
	

5).注入参数之null值和级联属性
	--->可以使用专用的<null/>元素标签为 Bean的 字符串或其他对象类型的属性值注入 null值；【用处不大，因为对象默认就是null】
	--->和Struts，Hibernat等框架一样，Spring支持级联属性的配置。
	
6).集合属性的注入
	--->在Spring中可以使用一组内置的XML标签(如：<list>，<set>或<map>)来配置Bean 的集合属性；
	--->配置java.util.List类型的属性，需要指定<list>标签，在标签里包含一些元素，这些标签可以通过<value>指向简单的常量值，也可以通过<ref>指定对其他Bean的引用。
		使用<bean>标签定义内部Bean，通过<null/>指定空元素，甚至可以内嵌其他集合；
	--->数组的定义和List一样，都使用<list>标签；
	--->配置java.util.Set需要使用<set>标签，定义元素的方法与<list>标签一样；
	--->配置java.util.Map通过<map>标签，<map>标签里可以使用多个<entry>作为子标签，每个条目包含一个键和一个值；
	--->必须在<key>标签里面定义键:
		因为键和值的类型没有限制，所以可以自由地为它们指定<value>,<ref>,<bean>或<null>元素；
	--->可以将Map的键和值作为<entry>的属性定义:
		简单常量使用key和value来定义；Bean引用通过key-ref和value-ref属性定义；
	--->使用<props>定义java.util.Properties，该标签使用多个<prop>作为自标签，每个标签必须定义key属性；

7).util命名空间的引入：
	--->可以使用<util:list>标签来指定一个独立的集合Bean，以提供给其他的Bean进行引用。
	--->需要先导入util命名空间；
		xmlns:util="http://www.springframework.org/schema/util"
		xsi:schemaLocation中添加：
			http://www.springframework.org/schema/util
			http://www.springframework.org/schema/util/spring-util.xsd
			
8).使用p命名空间
	--->为了简化Spring XML文件的配置，越来越多的XML文件采用属性而非子元素来配置信息；
	--->Spring从2.5版本开始引入了一个新的p命名空间，可以通过<bean>元素属性的方式配置Bean的属性；
	--->使用p命名空间后，基于XML的配置方式将进一步简化。
	--->需要先导入xmlns:p="http://www.springframework.org/schema/p" p的命名空间；
	

9).XML配置里的Bean自动装配
	--->Spring IOC容器可以自动装配Bean，需要做的仅仅是在<bean>的autowire属性指定自动装配的模式；
	--->byType(根据类型自动装配)；若IOC容器中有多个与目标Bean类型一致的Bean，在这种情况下，Spring将无法判定哪个Bean最适合该属性，所以不能执行自动装配。
	--->byName(根据名称自动装配)；必须将目标Bean的名称和属性名设置的完全相同；
	---constructor(通过构造器自动装配)；当Bean中存在多个构造器时，此种自动装配方式将会很复杂【并不推荐使用】；
	

10).XML配置里的Bean自动装配的缺点
	--->在Bean配置文件中设计autowire属性进行自动装配将会装备Bean的所有属性，然而，若只希望装配个别属性时，autowire就不够灵活了；
	--->autowire属性要么根据类型自动装配，要么根据名称自动装配，两者不能相互兼容；
	--->一般情况下，【在实际开发中很少使用自动装配功能，明确清晰的配置文件阅读性更强】；
	

11).继承Bean配置
	--->【Spring允许继承Bean的配置】，被继承的Bean 成为父Bean，继承这个父Bean的 Bean 称为子Bean；
	--->子Bean 从 父Bean 中继承配置，包括Bean的属性配置；
	--->子Bean 也可以覆盖从 父Bean 继承过来的属性；
	--->父Bean 可以作为配置模板，也可以作为Bean实例，若只想把父Bean 作为模板，【可以设置<bean>的abstract属性为true】，这样Spring就不会实例化这个Bean
	--->【并不是<bean>元素里所有的属性都会被继承，比如:autowire,abstract等】；
	--->也可以忽略父Bean 的class属性，让子Bean 指定自己的类，而共享相同的属性配置，【但此时，abstract属性必须为true】；
	

12).依赖Bean配置
	--->【Spring允许用户通过depends-on属性设定Bean前置依赖的Bean】，前置依赖的Bean会在当前Bean实例化之前创建好；
	--->【如果前置依赖于多个Bean，则可以通过逗号(,)，空格号的方式配置Bean的名称】
	
	
13).Bean的作用域
	--->配置bean的作用域使用<bean>元素的scope属性，其取值有singleton,prototype,【request,session,global session】；
	--->request,session,global session适用于Web应用程序，通常是和XmlWebApplicationContext共同使用；
	--->scope的默认值是singleton；


14).使用外部属性文件
	--->在配置bean时，有时需要在bean的配置里混入【系统部署的细节信息(如，文件路径，数据源配置等信息)】，而这些部署细节实际上需要和bean配置相分离；
	--->Spring提供了一个PropertyPlaceholderConfigurer的【BeanFactory后置处理器】，这个处理器允许用户将bean配置的部分内容外移到属性文件中，
		【可以在bean配置文件里使用形式为${var}的变量】，PropertyPlaceholderConfigurer从属性文件中加载属性，并使用这些属性来替代变量；
	--->【Spring还允许在属性文件中使用${propName}】，以实现属性之间的相互引用；
	
	注册PropertyPlaceholderConfigurer
		--->Spring2.0，需要在bean配置文件中配置一个类型为PropertyPlaceholderConfigurer的bean；
			<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
				<property name="location" value="classpath:jdbc.properties"></property>
			</bean>
		--->Spring2.5之后，可以通过<context:property-placeholder>元素来简化配置；
			1，在<beans>元素中添加contextSchema定义；
				xmlns:context="http://www.springframework.org/schema/context"
				xsi:schemaLocation中添加:
					http://www.springframework.org/schema/context  
					http://www.springframework.org/schema/context/spring-context.xsd  
			2，在配置文件中加入如下配置：
				<context:property-placeholder location="classpath:db.properties"/>


15).Spring表达式语句：SpEL
	--->【Spring表达式语句(简称SpEL)】：是一个支持运行时查询和操作对象图的强大的表达式语言；
	--->【其语法类似与EL：SpEL使用#{...}做界定符，所有在大括号中的字符都将被认定为SpEL】；
	--->【SpEL为 bean 的属性进行动态赋值提供了便利】
	--->通过SpEL可以实现：
		1，通过 bean 的id 对 bean 进行引用；
		2，通过方法以及引用对象中的属性；
		3，计算表达式的值；
		4，正则表达式的匹配；
		
	
	SpEL：字面量【SpEL使用字面值意义不大】
		--->整数 <property name="count" value="#{5}"/>
		--->小数 <property name="price" value="#{89.7}"/>
		--->科学计数法 <property name="capacity" value="#{1e4}">
		--->【Spring可以使用 单引号 或者 双引号 作为字符串的定界符号】：
			<property name="name" value="#{'Chuck'}"/> 或者 
			<property name="name" value="#{"Chuck"}"/>
		--->Boolean <property name="enable" value="#{false}"/>
		
	SpEL：引用Bean，属性和方法
		--->引用其他对象：
			<!-- 通过 value 属性和 SpEL 配置 bean 之间的关系，等同于ref="prefixGenerator" -->
			<property name="prefix" value="#{prefixGenerator}"></property>
			
		--->引用其他对象的属性：
			<!-- 通过 value 属性和 SpEL 配置 suffix 属性值为另一个 bean 的suffix 属性值 -->
			<property name="suffix" value="#{prefixGenerator2.suffix}"></property>
			
		--->调用其它方法，还可以链式操作：
			<!-- 通过 value 属性和 SpEL 配置 suffix 属性值为另一个 bean 的方法的返回值 -->
			<property name="suffix" value="#{prefixGenerator2.toString()}"></property>
			
			<!-- 方法的连缀 -->
			<property name="suffix"
				value="#{prefixGenerator2.toString().toUpperCase()}">
			</property>
		
		--->调用静态方法或静态属性：通过 T() 调用一个类的静态方法，它将返回一个Class Object，然后再调用相应的方法或属性
			<property name="initValue" value="#{T(java.lang.Math).PI}"/>
	
	SpEL：支持的运算符号
		--->逻辑运算符：and，or，not，|
			<property name="largeCircle" value="#{shape.kind == 'circle' and shape.perimeter gt 10000}">
			<property name="outOfStock" value="#{!product.available}">
			<property name="largeCircle" value="#{not product.available}">
			
		--->if-else运算符：	?:(temary), ?:(Elvis)【三目运算符】
			<constructor-arg
				value="#{songSelector.selectSong() == 'bily jean' ? piano : 'startcaft'}"/>
				
		--->if-else的变体:
			<constructor-arg
				value="#{kenny.song ?： 'bily jean'}"/>
				
		--->正则表达式：matches
			<constructor-arg
				value="#{admin.idCard matches '[a-zA-Z0-9]'}"/>

				

16).IOC容器中 Bean 的生命周期方法
	--->【Spring IOC容器可以管理Bean的生命周期】，Spring允许在Bean生命周期的特定点执行定制的任务
	--->Spring IOC容器对 Bean 的生命周期进行管理的过程：
		1，通过构造器或工厂方法创建 Bean 的实例；
		2，为Bean 的属性设置值和对其他 Bean 的引用；
		3，【调用 Bean 的初始化方法】；
		4，Bean 就可以使用了；
		5，当容器关闭时，调用Bean 的销毁方法；
	--->在Bean 的配置中设置 init-method 和destory-metho 属性，为 Bean 指定初始化和销毁方法；

	创建Bean 后置处理器
		--->Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理；
		--->Bean 后置处理器 对 IOC容器里的所有Bean 的实例逐一处理，而非单一实例，其典型应用是：
			检查Bean属性的正确性或根据特定的标准更改Bean属性
		--->对Bean 后置处理器而言，需要实现org.springframework.beans.factory.config.BeanPostProcessor接口
			在初始化被调用前后，Sprig将把每个Bean实例分别传递给上述接口的以下两个方法：
			1,postProcessAfterInitialization(Object bean,String beanName);
			2,postProcessBeforeInitialization(Object bean,String beanName);
			
	添加 Bean 后置处理器后 Bean 的生命周期
	--->Spring IOC容器对 Bean 的生命周期进行管理的过程：
		1，通过构造器或工厂方法创建 Bean 的实例；
		2，为 Bean 的属性设置和对其他 Bean 的引用；
		3，【将Bean 的实例传递给 Bean后置处理器的postProcessBeforeInitialization方法】;
		4，调用 Bean 的初始化方法；
		5，【将Bean 的实例传递给 Bean后只处理器的postProcessAfterInitialization方法】;
		6，Bean 就可以使用了;
		7，当容器关闭时，调用Bean 的销毁方法；