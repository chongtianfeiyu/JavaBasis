1).为什么要使用AOP？
	--->代码混乱：越来越多的非业务性的需求(日志和验证等)加入后，【原有的业务方法急剧膨胀，每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点】；
	--->代码分散：以日志需求为例，只是为了满足这个单一的需求，就不得不在多个模块(方法)中多次重复相同的日志代码，【如果日志需求发生变化，必须修改所有模块】；



2).使用动态代理来解决上述问题：
	--->代理设计模式的原理：
		【使用一个代理将对象包装起来】，然后用改代理对象取代原始对象，任何对原始对象的调用都要通过代理，
		代理对象决定是否以及何时将方法调用转到原始对象上。


3).什么是AOP？
	--->AOP(Aspect-Oriented Programming，面向切面编程)：是一种新的方法论，是对传统OOP的补充；
	--->AOP的主要编程对象是【切面(aspect)】，而【切面模块化横切关注点】；
	--->在应用AOP编程时，仍然需要定义公共功能，单可以明确的定义这个功能在哪里，以什么方式应用，并且不必修改受影响的类，
		这样一来【横切关注点酒杯模块化到特殊的对象(切面)里】；
	--->AOP的好处：
		1，每个事务逻辑位于一个对象，代码不分散，便于维护和升级；
		2，业务模块更加简洁，只包含核心业务代码；


4).AOP术语
	--->切面(aspect)，【横切关注点(跨越应用程序多个模块的功能)被模块化的特殊对象】；
	--->通知(Advice)，【切面必须要完成的工作】；
	--->目标(Target)，【被通知的对象】；
	--->代理(Proxy)，【向目标对象应用通知以后创建的对象】；
	--->连接点(Joinpoint)，【程序执行的某个特定位置】；如某个方法调用前，调用后，方法抛出异常后等，
		【连接点由两个信息确定：方法表示的程序执行点，相对点表示的方位】。
		例如，Calculate#add()方法执行前的连接点，执行点为Calculate#add()；方位为该方法执行前的位置；
	--->切点(pointcut)，每个类都有多个连接点；例如Calculate类中的所有方法都是连接点。即【连接点是程序类中客观存在的事务】。
		AOP通过切点定位到特殊的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系。
		一个切点匹配多个连接点，切点通过org.springframework.aop.Prointcut接口进行描述，它使用类和方法作为连接点的查询条件。
	--->

	
5).Spring AOP
	--->【AspectJ】：Java社区里最完整最流行的AOP框架；
	--->在Spring2.0以上版本，可以使用基于AspectJ注解或基于XML配置的AOP；
	--->操作流程如下：
		1，加入jar包：
			--->spring-aop-4.0.0.RELEASE.jar
			--->spring-aspects-4.0.0.RELEASE.jar
			--->aspectj-1.8.6.jar
			--->aspectj-weaver.jar
			--->aopalliance-.jar
		
		2，在配置文件中加入aop命名空间；
		3，【基于注解的AOP编程方式：需要在配置文件中加入<aop:aspectj-autoproxy></aop:aspectj-autoproxy>，为自动匹配的类生成代理对象】；
		4，把横切关注点的代码 抽象到切面的类中。
			--->【切面首先是一个IOC 中的 bean，即加入一个@Component注解】；
			--->切面还需要加入@Aspect注解；
		5，在切面类中声明各种通知：
			用AspectJ 注解声明切面：
			--->要在Spring中声明AspectJ切面，只需要在IOC容器中将切面声明了Bean实例；
			--->在AspectJ注解中，切面是一个带有@Aspect注解的Java类；
			--->通知是表示有某种注解的简答的Java方法；
			--->AspectJ支持5种类型的通知注解：
				1，@Before：前置通知，在方法执行之前执行；
				2，@After：后置通知，在方法之后执行；【无论是否发生异常都会执行通知方法】
				3，@AfterRunning：返回通知，在方法返回结果之前执行；
				4，@AfterThrowing：异常通知，在方法抛出异常之后；
				5，@Around：环绕通知，围绕着方法执行；
		
		6，利用方法签名编写AspectJ切入点表达式
			--->典型的切入点表达式是【根据方法的签名来匹配各种方法的】：
				1，execution * com.startcaft.spring.aop.helloworld.*(...)：
				匹配com.startcaft.spring.aop.helloworl包中声明的所有方法。
				第一个 * 代表任意修饰符及任意返回值；
				第二个 * 代表任意方法；
				... 代表匹配任意数量的参数；
				【若目标类或接口与该切面类在同一个包中，可以省略包名】；
				
				2，execution public * Interface.*(...)：
				匹配接口Interface中的所有public修饰的方法；
		
				
				3，execution public double Aclass.*(...)：
				匹配Aclass类中所有返回 double 数据类型的方法；
				
				4，execution public double Aclass.*(double,...)：
				匹配Aclass类中第一个参数类型为 double的方法；
				...匹配任意数量任意类型；
				
				5，exectuion public double Aclass.*(double,double)：
				匹配Aclass类中参数为 double,double的方法；
		
		7，让切面通知访问当前连接点的细节：
			--->可以在切面的通知方法中声明一个类型为JoinPoint的参数，然后就能访问连接点的细节，如方法名和参数值，参数类型等。